# 알고리즘의 시간 복잡도 분석  
## 1. 도입  
한 가지 항목이 전체의 대소를 좌지우지하는 것을 지배한다(dominate)고 표현한다.  
알고리즘의 수행 시간을 지배하는 것은 반복문이다.  
입력의 크기가 커질수록 반복문이 알고리즘의 수행 시간을 지배한다.  
알고리즘의 수행 시간을 반복문이 수행되는 횟수로 측정 -> 반복문의 수행 횟수는 입력의 크기이 대한 함수로 표현  
  
## 2. 선형 시간 알고리즘  
이동 평균(moving average)은 주식의 가격, GDP, 몸무게 등 시간이 따라 변화라는 값들을 관찰할 때 유용하게 사용할 수 있는 통계적 기준이다.  
시간에 따라 관찰된 숫자들이 주어질 때 M-이동 평균은 마지막 M개의 관찰 값의 평균으로 정의한다. 따라서 새 관찰 값이 나오면 M-이동 평균은 새 관찰 값을 포함하도록 바뀐다.  
이동평균선 알고리즘 개선 : n개 입력과 m개 평균을 각각 for문으로 중첩하던 것을 m-1일에 구했던 몸무게 합에서 맨 앞에 데이터를 빼고 m번째 데이터를 더하는 식으로 중첩된 for문 분리  
수행 시간이 n에 정비례하는데 이런 알고리즘을 선형 시간(linear time) 알고리즘이라 한다.  
  
## 3. 선형 이하 시간 얼고리즘  
입력의 크기가 커지는 것보다 수행 시간이 느리게 증가하는 얼고리즘들을 선형 이하 시간(sublinear time) 알고리즘이라 한다.  
이진 탐색 : 전체를 2개로 쪼개어 탐색하는 과정을 반복하는 방법  
  
## 4. 지수 시간 알고리즘  
반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘.  
생각보다 지수 시간보다 빠른 알고리즘을 찾기 쉽지않다.  
  
## 5 시간 복잡도(time complexity)  
알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력 크기에 대한 함수로 표현한 것.  
1. 기본적인 연산이란 더 작게 쪼갤 수 없는 최소 크기의 연산  
  1. 두 부호 있는 32비트 정수의 사칙연산
  2. 두 실수형 변수의 대소 비교
  3. 한 변수에 다른 변수 대입하기
1. 다음은 반복문을 포함하기 때문에 기본적인 연산이 아님
  1. 정수 배열 정렬하기
  2. 두 문자열이 서로 같은지 확인하기
  3. 입력된 수 소인수 분해하기
가장 깊이 중첩된 반복문 내부에 있는 기본적안 연산들은 더 쪼갤 수 없기 때문에 시간 복잡도의 대략적인 기준이 된다.  
시간복잡도는 완전한 속도의 기준이 아님->입력 크기가 작을 경우 큰 의미를 갖지 못함.  
점근적 시간 표기 : O표기  
O표기법(Big-O Notation)은 간단하게 말해 주어진 함수에서 가장 빨리 증가하는 항만을 남긴 채 나머지를 다 버리는 표기법이다. 시간 복잡도는 반복문에 의해 결정. 각 경우의 수행 시간을 간단히 나타내는 표기법일 뿐, 특별히 최악의 수행 시간과 관련이 있는 것은 아니다.  
